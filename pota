#!/usr/bin/python3

# Hey mu-jed, this is -*- Python -*-

# Imports
import configparser
import datetime
import getopt
import json
import os
import re
import sys
import time
from typing import Callable
from dataclasses import dataclass
from pathlib import Path
import requests


###############################################################################
#                                  Variables                                  #
###############################################################################


# Time constants
SECOND = 1.0
MINUTE = 60 * SECOND
HOUR = 60 * MINUTE
DAY = 24 * HOUR
WEEK = 7 * DAY

# Variables set from command line options
debugOutput = False
cacheDir = None
fromCache = False
jsonOutput = False
rateLimit = None
readCache = True
writeCache = True

# Configuration items
config = None

# Connection related variables
session = None
defaultRateLimit = 0.010 * SECOND
lastApiCall = None

# Cache configuration
@dataclass
class CacheDef:
    holdTime:   float
    genName:    Callable[[str, str], str]

cacheConfig = {
    'activator':
        CacheDef(1 * DAY, lambda year, _u1 = "": f"activator{'' if year is None else f'-{year}'}.json"),
    'callProfile':
        CacheDef(2 * HOUR, lambda call, _u1 = "": f"callprofile-{call}.json"),
    'callStats':
        CacheDef(2 * HOUR, lambda call, _u1 = "": f"callstats-{call}.json"),
    'callsigns':
        CacheDef(1 * WEEK, lambda _u1 = "", _u2 = "": "callsigns.json"),
    'countries':
        CacheDef(1 * WEEK, lambda _u1 = "", _u2 = "": f"programs.json"),
    'leaderboard':
        CacheDef(2 * HOUR, lambda park, _u1 = "": f"leaderboard-{park}.json"),
    'locations':
        CacheDef(1 * WEEK, lambda _u1 = "", _u2 = "": f"locations.json"),
    'parkActivations':
        CacheDef(2 * HOUR, lambda park, _u1 = "": f"activations-{park}.json"),
    'parkProfile':
        CacheDef(1 * DAY, lambda park, _u1 = "": f"parkprofile-{park}.json"),
    'parkStats':
        CacheDef(2 * HOUR, lambda park, _u1 = "": f"parkstats-{park}.json"),
    'parks':
        CacheDef(2 * DAY, lambda region, _u1 = "": f"parks-{region}.json"),
    'spotComments':
        CacheDef(30 * SECOND, lambda call, park: f"spotcomments-{call}-{park}.json"),
    'spots':
        CacheDef(30 * SECOND, lambda _u1 = "", _u2 = "": "spots.json")
}

cleanupConfig = {
    'activations':      'parkActivations',
    'activator':        'activator',
    'programs':         'countries',
    'leaderboard':      'leaderboard',
    'locations':        'locations',
    'parks':            'parks',
    'parkprofile':      'parkProfile',
    'callprofile':      'callProfile',
    'parkstats':        'parkStats',
    'callstats':        'callStats',
    'spots':            'spots',
    'spotcomments':     'spotComments'
}


###############################################################################
#                              Helper functions                               #
###############################################################################


# Print an error to stderr and exit
def error(msg):
    print(f"Error: {msg}", file = sys.stderr)
    sys.exit(1)


# Print a debug message to stderr if debug output is enabled
def debug(msg):
    if debugOutput:
        print(msg, file = sys.stderr, flush = True)


# Get options with error checking
def getOpt(args, shortopts, longopts = None, useGnu = False):
    if longopts is None:
        longopts = []
    try:
        if useGnu:
            return getopt.gnu_getopt(args, shortopts, longopts)
        else:
            return getopt.getopt(args, shortopts, longopts)
    except getopt.GetoptError as e:
        error(f"{e}")


# Check that an argument list contains at least one member
def requireArg(args, cmd):
    if len(args) == 0:
        error(f'The command "{cmd}" requires at least one argument')


# Check that the argument list for a command is empty
def noArgs(args, cmd):
    if len(args) != 0:
        error(f'Unexpected arguments to \"{cmd}\": {" ".join(args)}')


# Format some json object and print it to stdout
def printJson(text):
    formatted = json.dumps(text, indent=4)
    print(formatted)


# Check if the given token is a ham radio band
def isBand(token):
    return re.search("^[0-9]+C?M$", token, flags = re.I) is not  None


# Check if the given token is an operating mode
def isMode(token):
    return re.search("^(AM|CW|DATA|FM|FT4|FT8|PHONE|PSK31|RTTY|SSB|SSTV)$", token, flags = re.I) is not None


# Check if the given token is a park id
def isPark(token):
    return re.search("^([A-Z]{2}-[0-9]{4,5}|K-TEST)$", token, flags = re.I) is not None


# Check if the given token denotes a region
def isRegion(token):
    return re.search("^[A-Z]{2}-[A-Z]{2,3}$", token, flags = re.I) is not None


# Check if the given token denotes a country
def isCountry(token):
    return re.search("^[A-Z]{2}$", token, flags = re.I) is not None


# Check if the given token denotes a frequency
def isFreq(token):
    return re.search("^[0-9]+(\\.[0-9]*)?$", token) is not None


# Check if s string is a valid regex
def isValidRegEx(regex):
    try:
        re.compile(regex)
        return True
    except re.error:
        return False


# Return program information from SVN in a dict
def getVersion():
    svnId = "$Id: pota 3687 2025-02-14 19:56:56Z uz $"
    idPat = '\\d+'
    datePat = '\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}'
    userPat = '\\w+'
    m = re.search(f'^\\$Id: pota ({idPat}) ({datePat})Z ({userPat}) \\$$', svnId)
    if m is not None:
        return {
            'version': m[1],
            'lastChange': m[2],
            'author': m[3]
        }
    else:
        return None


# Add a colon to a string (seems simple but allows easier formatting)
def withColon(arg):
    return arg + ":"


# Encode a call for use within an URL
def encodeCall(call):
    # We only have slashes in calls so just replace these
    return call.replace("/", "%2F")


# Filter a list and returned a filtered variant
def filterList(data, func):
    result = [ ]
    for d in data:
        if func(d):
            result.append(d)
    return result


# Make sure the session object exists and is usable
def openSession():
    global session

    if session is None:
        session = requests.Session()
        programInfo = getVersion()
        version = "unknown" if programInfo is None else programInfo["version"]
        session.headers = {
            "accept": "application/json, text/plain, */*",
            "accept-encoding": "gzip, deflate",
            "Content-Type": "application/json",
            "origin": "https://pota.app",
            "referer": "https://pota.app/",
            'user-agent': f"pota/{version}"
        }


# Call an API returning the response text. Will abort on any errors. The
# function allows to use a cache file.
def callApi(url, cache, maxAge):
    global fromCache, lastApiCall, rateLimit, readCache, session, writeCache

    # Try to read from the cache
    if readCache:
        cachePath = cacheDir / cache
        debug(f"Trying to read {url} from {cachePath}")
        try:
            res = cachePath.stat()
            now = time.time()
            if fromCache or res.st_mtime >= now - maxAge:
                debug(f"Returning cached data for {url}")
                return cachePath.read_text()
        except Exception:
            # No cache file or error accessing it. Read from the net or fail.
            if fromCache:
                error(f'Document \"{cache}\" not availabke in cache')
            else:
                debug(f"No cache file found for {url}")

    # File not found in cache. Rate limit API calls if requested.
    if rateLimit is not None and lastApiCall is not None:
        timeLeft = (lastApiCall + rateLimit) - time.time()
        if timeLeft > 0:
            debug(f'Rate limiting API call - sleeping {timeLeft:.3f} seconds')
            time.sleep(timeLeft)

    # Do the actual API call
    try:
        openSession()
        response = session.get(url)
    except Exception as e:
        error(f"Cannot open url: {url} ({e})")
    if response.status_code == 404:
        error(f'Cannot retrieve data: {response.text}')
    if response.status_code != 200:
        error('Cannot retrieve data')
    responseText = response.text
    if rateLimit is not None:
        lastApiCall = time.time()

    # Write to the cache if one was given
    if writeCache and cache != "":
        # Ignore errors when writing to the cache file. The effect is just that
        # nothing is cached.
        try:
            cachePath = cacheDir / cache
            debug(f"Writing data for {url} to {cachePath}")
            cachePath.write_text(responseText)
        except Exception as e:
            debug(f"Exception {e}")

    # Done
    return responseText


# Call an API, convert the response to a JSON object and return it.
def callJson(url, cache, maxAge):
    response = callApi(url, cache, maxAge)
    try:
        jsonData = json.loads(response)
    except Exception as e:
        error(f"Error converting response from {url} into json: {e}")
    return jsonData


# Call an API, read the response as JSON and make sure its a list.
def callJsonList(url, cache, maxAge):
    jsonData = callJson(url, cache, maxAge)
    if not isinstance(jsonData, list):
        error(f"Unexpected response from {url}: Not an array")
    return jsonData


# Post json data to a POTA API
def postJson(url, data):
    # Post the data
    try:
        openSession()
        response = session.post(url, json = data)
    except Exception as e:
        error(f"Cannot open url: {url} ({e})")
    if response.status_code != 200:
        error(f'Cannot post spot data: {response.text}')

    return response.text


###############################################################################
#                                Configuration                                #
###############################################################################


def configName():
    return Path.home() / ".pota"


def readConfig():
    global config
    config = configparser.ConfigParser()
    try:
        config.read(configName())
    except Exception:
        pass
    # Fill in default values. We do this even if we could read the config since
    # newer version of the config may introduce new keys.
    if not config.has_section('auth'):
        config.add_section('auth')
    if not config.has_section('general'):
        config.add_section('general')

    if not config.has_option('auth', 'user'):
        config.set('auth', 'user', '')
    if not config.has_option('auth', 'password'):
        config.set('auth', 'password', '')

    if not config.has_option('general', 'callsign'):
        config.set('general', 'callsign', '')


def writeConfig():
    global config
    try:
        # Make sure we create the config in mode 0600
        handle = os.open(
            path = configName(),
            flags = os.O_WRONLY | os.O_CREAT  | os.O_TRUNC,
            mode = 0o600
        )
        with open(handle, 'w') as configFile:
            config.write(configFile)
    except Exception as e:
        error(f'Error writing to {configName()}: {e}')


###############################################################################
#                         Full API calls with caching                         #
###############################################################################


def getParkActivations(park):
    url = f"https://api.pota.app/park/activations/{park}?count=all"
    cfg = cacheConfig['parkActivations']
    return callJson(url, cfg.genName(park), cfg.holdTime)


def getCallActivations(call):
    # First grab the profile and read all activated parks
    profile = getCallProfile(call)
    if not "recent_activity" in profile:
        return []
    if not "activations" in profile["recent_activity"]:
        return []
    return profile["recent_activity"]["activations"]


def getActivator(years):
    cfg = cacheConfig['activator']
    if len(years) == 0:
        # No year given, return full list
        url = f"https://api.pota.app/activator/all"
        return callJsonList(url, cfg.genName(None), cfg.holdTime)
    else:
        # Multiple years - we must merge them
        entriesByCall = { }
        for year in years:
            url = f"https://api.pota.app/activator/all?year={year}"
            entriesFromYear = callJsonList(url, cfg.genName(year), cfg.holdTime)
            for entry in entriesFromYear:
                call = entry["activeCallsign"]
                existing = entriesByCall.get(call);
                if existing is None:
                    entriesByCall[call] = entry;
                else:
                    for field in [ "activations", "units", "TotalContacts", "TotalCWContacts", "TotalDataContacts", "TotalPhoneContacts" ]:
                        existing[field] = str(int(existing[field]) + int(entry[field]))
        # Convert to list and return
        return list(entriesByCall.values())


def getAwards(call):
    # Awards are part of the call profile
    profile = getCallProfile(call)
    if not "awards" in profile:
        return []
    return profile["awards"]


def getCountries():
    url = f"https://api.pota.app/programs/locations"
    cfg = cacheConfig['countries']
    return callJsonList(url, cfg.genName(), cfg.holdTime)


def getLeaderboard(park):
    url = f"https://api.pota.app/park/leaderboard/{park}"
    cfg = cacheConfig['leaderboard']
    return callJson(url, cfg.genName(park), cfg.holdTime)


def getLocations():
    url = f"https://api.pota.app/locations"
    cfg = cacheConfig['locations']
    return callJsonList(url, cfg.genName(), cfg.holdTime)


def getParks(regions):
    if isinstance(regions, list):
        # Argument is a region list. Read the parks for all these regions.
        # Take care that parks that span multiple regions are just added once.
        parks = [ ]
        addedRefs = { }
        for region in regions:
            for park in getParks(region):
                ref = park["reference"]
                if not ref in addedRefs:
                    parks.append(park)
                    addedRefs[ref] = True
        return parks
    else:
        # Argument is a single region
        url = f"https://api.pota.app/location/parks/{regions}"
        cfg = cacheConfig['parks']
        return callJsonList(url, cfg.genName(regions), cfg.holdTime)


def getParkProfile(park):
    url = f"https://api.pota.app/park/{park}"
    cfg = cacheConfig['parkProfile']
    return callJson(url, cfg.genName(park), cfg.holdTime)


def getCallProfile(call):
    url = f"https://api.pota.app/profile/{encodeCall(call)}"
    cfg = cacheConfig['callProfile']
    return callJson(url, cfg.genName(call), cfg.holdTime)


def getRegions(country = None):
    countries = getCountries()
    if country is not None:
        countries = filterList(countries, lambda e: e["prefix"] == country)
    regions = [ ]
    for c in countries:
        for entity in c["entities"]:
            for region in entity["locations"]:
                regions.append(region)
    return regions


def getParkStats(park):
    url = f"https://api.pota.app/park/stats/{park}"
    cfg = cacheConfig['parkStats']
    return callJson(url, cfg.genName(park), cfg.holdTime)


def getCallStats(call):
    url = f"https://api.pota.app/stats/user/{encodeCall(call)}"
    cfg = cacheConfig['callStats']
    return callJson(url, cfg.genName(call), cfg.holdTime)


def getSpots():
    url = "https://api.pota.app/spot/activator/"
    cfg = cacheConfig['spots']
    spots = callJsonList(url, cfg.genName(), cfg.holdTime)
    # Fixup the spots: An empty mode means "SSB". Also add band information.
    for spot in spots:
        if spot["mode"] == "":
            spot["mode"] = "SSB"
        freq = float(spot["frequency"])
        if 135.7 <= freq <= 135.8:
            spot["band"] = "2200M"
        elif 472.0 <= freq <= 479.0:
            spot["band"] = "630M"
        elif 1810.0 <= freq <= 2000.0:
            spot["band"] = "160M"
        elif 3500.0 <= freq <= 4000.0:
            spot["band"] = "80M"
        elif 7000.0 <= freq <= 7300.0:
            spot["band"] = "40M"
        elif 10100.0 <= freq <= 10150.0:
            spot["band"] = "30M"
        elif 1400.0 <= freq <= 14350.0:
            spot["band"] = "20M"
        elif 1868.0 <= freq <= 18168.0:
            spot["band"] = "17M"
        elif 2100.0 <= freq <= 21450.0:
            spot["band"] = "15M"
        elif 24890.0 <= freq <= 24990.0:
            spot["band"] = "12M"
        elif 2800.0 <= freq <= 29700.0:
            spot["band"] = "10M"
        elif 50000.0 <= freq <= 52000.0:
            spot["band"] = "6M"
        elif 70000.0 <= freq <= 70500.0:
            spot["band"] = "4M"
        elif 144000.0 <= freq <= 148000.0:
            spot["band"] = "2M"
        elif 430000.0 <= freq <= 440000.0:
            spot["band"] = "70CM"
        elif 1240000.0 <= freq <= 1300000.0:
            spot["band"] = "23CM"
        else:
            spot["band"] = "unknown"
    return spots


def getSpotComments(call, park):
    url = f"https://api.pota.app/spot/comments/{encodeCall(call)}/{park}/"
    cfg = cacheConfig['spotComments']
    comments = callJsonList(url, cfg.genName(call, park), cfg.holdTime)
    return comments


###############################################################################
#                               Output routines                               #
###############################################################################


def outputCallActivations(activations):
    global jsonOutput
    if jsonOutput:
        printJson(activations)
        return

    # The date string compares alphabetically
    sortedActivations = sorted(activations, key = lambda act : act["date"])
    for act in sortedActivations:
        park = act["reference"]
        cw = act["cw"]
        data = act["data"]
        phone = act["phone"]
        total = act["total"]
        print(f'{act["date"]}: {park} (cw: {cw}, data: {data}, phone: {phone}, total: {total})')


def outputParkActivations(activations):
    global jsonOutput
    if jsonOutput:
        printJson(activations)
        return

    # The date string compares alphabetically
    sortedActivations = sorted(activations, key = lambda act : act["qso_date"])
    for act in sortedActivations:
        d = act["qso_date"]
        date = f'{d[:4]}-{d[4:6]}-{d[6:8]}'
        call = act["activeCallsign"]
        cw = act["qsosCW"]
        data = act["qsosDATA"]
        phone = act["qsosPHONE"]
        total = act["totalQSOs"]
        print(f'{date}: {call} (cw: {cw}, data: {data}, phone: {phone}, total: {total})')


def outputActivators(activators):
    global jsonOutput
    if jsonOutput:
        printJson(activators)
        return

    for entry in activators:
        act = entry["activations"]
        call = withColon(entry["activeCallsign"])
        cw = int(entry["TotalCWContacts"])
        data = int(entry["TotalDataContacts"])
        phone = int(entry["TotalPhoneContacts"])
        total = int(entry["TotalContacts"])
        if total == 0:
            error('total QSOs == 0 in activator data')
        cwP = float(cw) / float(total)
        dataP = float(data) / float(total)
        phoneP = float(phone) / float(total)
        print(
            f'{call:<10} {act:>5} (' +
            f'cw: {cw}[{cwP * 100.0:.1f}%], ' +
            f'data: {data}[{dataP * 100.0:.1f}%], ' +
            f'phone: {phone}[{phoneP * 100.0:.1f}%], ' +
            f'total: {total})'
        )


def outputActivatorTotals(activators):
    global jsonOutput
    if jsonOutput:
        # No output in this case
        return

    count = len(activators)
    act = 0
    qsos = 0
    cw = 0
    data = 0
    phone = 0
    for e in activators:
        act += int(e["activations"])
        qsos += int(e["TotalContacts"])
        cw += int(e["TotalCWContacts"])
        data += int(e["TotalDataContacts"])
        phone += int(e["TotalPhoneContacts"])
    if qsos > 0:
        cwP = float(cw) / float(qsos)
        dataP = float(data) / float(qsos)
        phoneP = float(phone) / float(qsos)
    else:
        cwP = 0.0
        dataP = 0.0
        phoneP = 0.0
    print(
        f'{count} callsigns, {act} activations, {qsos} QSOs ' +
        f'(cw: {cw}[{cwP * 100.0:.1f}%], ' +
        f'data: {data}[{dataP * 100.0:.1f}%], ' +
        f'phone: {phone}[{phoneP * 100.0:.1f}%])'
    )


def outputAwards(awards):
    global jsonOutput
    if jsonOutput:
        printJson(awards)
        return

    # The ISO time string compares alphabetically
    sortedAwards = sorted(awards, key = lambda award : award["granted"])
    for award in sortedAwards:
        endorsements = award["endorsements"]
        e = "" if len(endorsements) == 0 else f'({", ".join(endorsements)})'
        print(f'{award["granted"][:10]}: {award["name"]} {e}')


def outputCountries(countries):
    global jsonOutput
    if jsonOutput:
        printJson(countries)
        return

    for c in countries:
        ecount = c["entities"]
        e = "entity" if ecount == 1 else "entities"
        pcount = c["parks"]
        p = "park" if pcount == 1 else "parks"
        print(f'{withColon(c["prefix"]):<8}{c["name"]} ({ecount} {e}, {pcount} {p})')


def outputLeaderboard(data):
    global jsonOutput
    if jsonOutput:
        printJson(data)
        return

    print(f'Park Leaders by Activations:')
    for act in data["activations"]:
        print(f'  {act["callsign"]:<16s}{act["count"]}')
    print()

    print(f'Park Leaders by QSOs:')
    for act in data["activator_qsos"]:
        print(f'  {act["callsign"]:<16s}{act["count"]}')
    print()

    print(f'Park Leaders by Hunter QSOs:')
    for act in data["hunter_qsos"]:
        print(f'  {act["callsign"]:<16s}{act["count"]}')
    print()


def outputLocations(locations):
    global jsonOutput
    if jsonOutput:
        printJson(locations)
        return

    for loc in locations:
        header = f'{loc["locationDesc"]}:'
        print(f'{header:<12s}{loc["entityName"]} / {loc["locationName"]}')


def outputMayor(parks):
    global jsonOutput
    if jsonOutput:
        printJson(parks)
        return

    for park in sorted(parks, key = lambda park: park["reference"]):
        line = ""
        if "mayor" in park:
            line = f'{withColon(park["reference"]):<12}{park["mayor"]["callsign"]} '
            line += f'(mayor with {park["mayor"]["count"]} {park["mayor"]["unit"]})'
        if "deputy" in park:
            if len(line) == 0:
                line = f'{withColon(park["reference"]):<12}{park["deputy"]["callsign"]} '
            else:
                line += f', {park["deputy"]["callsign"]} '
            line += f'(deputy with {park["deputy"]["count"]} {park["deputy"]["unit"]})'
        print(line)

def outputParks(parks):
    global jsonOutput
    if jsonOutput:
        printJson(parks)
        return

    for park in parks:
        print(f'===== {park["reference"]} =====')
        print(f'Name:                   {park["name"]}')
        print(f'Regions:                {park["locationDesc"]}')
        print(f'Activations:            {park["activations"]}')
        print(f'Attempts:               {park["attempts"]}')
        print(f'QSOs:                   {park["qsos"]}')
        if "firstActivator" in park:
            activator = park["firstActivator"]
            if activator != "":
                print(f'First activated:        {park["firstActivationDate"]} by {activator}')
            else:
                print(f'First activated:        never')

def outputCallProfile(profile):
    global jsonOutput
    if jsonOutput:
        printJson(profile)
        return

    stats = profile["stats"]
    activator = stats["activator"]
    attempts = stats["attempts"]
    hunter = stats["hunter"]

    print(f'===== {profile["callsign"]} - {profile["name"]} =====')
    print(f'QTH:                    {profile["qth"]}')
    print(f'Other callsigns:        {", ".join(profile["other_callsigns"])}')
    print(f'Activations:            {activator["activations"]} / {attempts["activations"]}')
    print(f'Parks activated:        {activator["parks"]} / {attempts["parks"]}')
    print(f'Activation QSOs:        {activator["qsos"]} / {attempts["qsos"]}')
    print(f'Parks hunted:           {hunter["parks"]}')
    print(f'Hunter QSOs:            {hunter["qsos"]}')
    print(f'Awards:                 {stats["awards"]}')
    print(f'Endorsements:           {stats["endorsements"]}')
    print('')


def outputParkProfile(profile):
    global jsonOutput
    if jsonOutput:
        printJson(profile)
        return

    print(f'===== {profile["name"]} {profile["parktypeDesc"]} =====')
    print(f'Reference:              {profile["reference"]}')
    print(f'Entity:                 {profile["entityName"]}')
    print(f'Location(s):            {profile["locationDesc"]}')
    print(f'Active:                 {"yes" if profile["active"] else "no"}')
    if "firstActivator" in profile:
        print(f'First activation:       {profile["firstActivator"]} on {profile["firstActivationDate"]}')
    else:
        print(f'First activation:       never')
    print('')


def outputRegions(regions):
    global jsonOutput
    if jsonOutput:
        printJson(regions)
        return

    for r in regions:
        print(f'{withColon(r["descriptor"]):<8}{r["name"]} ({r["parks"]} parks)')


def outputCallStats(stats):
    global jsonOutput
    if jsonOutput:
        printJson(stats)
        return

    print(f'===== {stats["callsign"]} =====')
    print(f'Name:                   {stats["name"]}')
    print(f'QTH:                    {stats["qth"]}')
    print(f'Successful activations: {stats["activator"]["activations"]}')
    print(f'Activated parks:        {stats["activator"]["parks"]}')
    print(f'Activation QSOs:        {stats["activator"]["qsos"]}')
    print(f'Hunted parks:           {stats["hunter"]["parks"]}')
    print(f'Hunter QSOs:            {stats["hunter"]["qsos"]}')
    print(f'Awards:                 {stats["awards"]}')
    print(f'Endorsements:           {stats["endorsements"]}')
    print('')

def outputParkStats(stats):
    global jsonOutput
    if jsonOutput:
        printJson(stats)
        return

    print(f'===== {stats["reference"]} =====')
    print(f'Successful activations: {stats["activations"]}')
    print(f'Activation attempts:    {stats["attempts"]}')
    print(f'QSOs:                   {stats["contacts"]}')
    print('')


def outputSpots(spots):
    global jsonOutput
    if jsonOutput:
        printJson(spots)
        return

    for spot in spots:
        print(f'===== {spot["activator"]} @ {spot["reference"]} =====')
        print(f'Location:    {spot["reference"]} {spot["name"]}')
        print(f'Region:      {spot["locationDesc"]}')
        # "mode" and "frequency" are duplicated below but we print it also
        # here for better visibility
        print(f'Mode:        {spot["mode"]}')
        print(f'Frequency:   {spot["frequency"]}')
        spotters = spot["spotters"]
        for spotter in spotters:
            spotTime = datetime.datetime.fromisoformat(spotter["spotTime"])
            spottedBy = spotter["spotter"]
            time = spotTime.strftime("%H:%M:%S")
            mode = spotter["mode"]
            frequency = spotter["frequency"]
            comment = spotter["comments"]
            comment = f' ("{comment}")' if comment != '' else ''
            print(f'Spotted:     {time} by {spottedBy} in {mode} at {frequency}{comment}')
        print('')


###############################################################################
#                          Command handling functions                         #
###############################################################################


def readActivations(args):
    # Parse the command arguments. We accept -u to include unsuccessful ones.
    opts, tokens = getOpt(args, 'u', [ 'unsuccessful' ])
    unsuccessful = False
    for opt, arg in opts:
        if opt in [ '-u', '--unsuccessful' ]:
            unsuccessful = True

    # Call or park id is mandatory argument
    requireArg(tokens, "activations")
    arg = tokens[0].upper()

    if isPark(arg):
        activations = getParkActivations(arg)
        if not unsuccessful:
            activations = filterList(activations, lambda e: int(e["totalQSOs"]) >= 10)
        outputParkActivations(activations)
    else:
        activations = getCallActivations(arg)
        if not unsuccessful:
            activations = filterList(activations, lambda e: int(e["total"]) >= 10)
        outputCallActivations(activations)


def readActivators(args):
    modeRegex = re.compile(
        "(?P<negate>\\^)?" +
        "(?P<mode>cw|data|phone)" +
        "(?P<cmp>[<>][0-9]+(\\.[0-9]*)?%?)?",
        re.IGNORECASE
    )

    # Parse the command arguments. We accept -u to include unsuccessful ones.
    opts, tokens = getOpt(
        args,
        'ac:m:tTy:',
        [
            'activations',
            'call=',
            'mode=',
            'total',
            'TOTAL', 'year='
        ]
    )
    act = False
    callFilters = []
    modeFilters = []
    total = 0
    years = []
    for opt, arg in opts:
        if opt in [ '-a', '--activations' ]:
            act = True
        elif opt in [ '-c', '--cilter' ]:
            try:
                expected = not arg.startswith("^")
                if not expected:
                    arg = arg[1:]
                callFilter = re.compile(arg, re.IGNORECASE)
                callFilters.append({ "expected" : expected, "regex" : callFilter})
            except re.error:
                error(f"Not a valid regular expression: \"{arg}\"")
        elif opt in [ '-m', '--mode' ]:
            filterDefs = []
            for tok in arg.lower().split(","):
                match = modeRegex.fullmatch(tok)
                if match is None:
                    error(f"Invalid mode {tok} in argument to {opt}")
                negate = not match.group("negate") is None
                mode = match.group("mode")
                cmp = match.group("cmp")
                less = None if cmp is None else cmp.startswith("<")
                if not less is None:
                    cmp = cmp[1:]
                percent = False if cmp is None else cmp.endswith("%")
                if percent:
                    cmp = cmp[:-1]
                filterDef = {
                    "expected" : not negate,
                    "mode" : mode,
                    "less" : less,
                    "cmp" : None if cmp is None else float(cmp),
                    "percent" : percent
                }
                filterDefs.append(filterDef)
            modeFilters.append(filterDefs)

        elif opt in [ '-t', '--total' ]:
            total = 1
        elif opt in [ '-T', '--TOTAL' ]:
            total = 2
        elif opt in [ '-y', '--year' ]:
            for year in arg.split(","):
                try:
                    year = int(year)
                except ValueError:
                    error(f"Not a valid year: {year}")
                if year < 100:
                    year += 2000
                if year < 2000 or year > 2040:
                    error(f"The given year {arg} is out of range")
                years.append(year)

    # No other arguments allowed
    noArgs(tokens, "activators")

    # Read all activators optionally for one year then apply any filters given
    activators = getActivator(years);
    for callFilter in callFilters:
        expected = callFilter["expected"]
        regex = callFilter["regex"]
        activators = filterList(
            activators,
            lambda e: (regex.fullmatch(e["activeCallsign"]) is not None) == expected
        )
    for filterDefs in modeFilters:
        filtered = [ ]
        for filterDef in filterDefs:
            mode = filterDef["mode"]
            expected = filterDef["expected"]
            compareVal = filterDef["cmp"]
            less = filterDef["less"]
            percent = filterDef["percent"]
            if mode == "cw":
                field = "TotalCWContacts"
            elif mode == "data":
                field = "TotalDataContacts"
            elif mode == "phone":
                field = "TotalPhoneContacts"
            def filter(entry):
                value = entry[field]
                if compareVal is None:
                    return (value > 0) == expected
                if percent:
                    value = value / float(entry["TotalContacts"]) * 100.0
                if less:
                    return (value < compareVal) == expected
                else:
                    return (value > compareVal) == expected
            filtered += filterList(activators, filter)
        activators = filtered
        if len(activators) == 0:
            break

    # Sort the output then print it
    if act:
        activators.sort(key = lambda e : int(e["activations"]), reverse = True)
    else:
        activators.sort(key = lambda e : e["activeCallsign"])
    if total != 2:
        outputActivators(activators)
    if total > 0:
        outputActivatorTotals(activators)


def readAwards(args):
    # Call is mandatory argument
    requireArg(args, "awards")
    call = args[0].upper()

    outputAwards(getAwards(call))


def cleanupCache(args):
    global cleanupConfig

    # We cannot cleanup if we aren't allowed to write the cache
    if not writeCache:
        error("Command \"cleanup\" requires writing to the cache directory")
    # Get the current time once
    now = time.time()
    # Process all entries in the cache. We cannot delete files while iterating
    # so collect them first and delete later.
    outdatedEntries = [ ]
    errors = False
    try:
        for entry in cacheDir.iterdir():
            # Check if this is a known cache entry
            if not entry.is_file():
                errors = True
                print(f"Non file entry in cache directory: {entry}", file = sys.stderr)
                continue
            m = re.search('^[a-z]+', entry.name, re.IGNORECASE)
            key = None if m is None else cleanupConfig.get(m[0])
            if key is None:
                errors = True
                print(f"Unknown file in cache directory: {entry}", file = sys.stderr)
                continue
            # Check the files age
            maxAge = cacheConfig[key].holdTime
            res = entry.stat()
            if res.st_mtime < now - maxAge:
                outdatedEntries.append(entry)
                debug(f"Outdated cache file: {entry}")
            else:
                debug(f"File is still hot: {entry}")
        # Remove all outdated entries
        for entry in outdatedEntries:
            debug(f"Removing {entry}")
            entry.unlink()
    except Exception as e:
        error(f"Error in cleanup: {e}")
    # Return a non zero exit code if something was suspicious
    if errors:
        sys.exit(1)


def editConfig(args):
    global config

    # The arguments may be either "section.key" for a config variable which is
    # then output or "section.key=value" to set a config variable to the given
    # value.
    requireArg(args, "config")
    for arg in args:
        value = None
        index = arg.find("=")
        if index >= 0:
            value = arg[index + 1:]
            arg = arg[:index]
        index = arg.find(".")
        if index < 0:
            error(f'Invalid config variable name: {arg}')
        section = arg[:index]
        key = arg[index + 1:]
        if not config.has_section(section):
            error(f'Invalid config variable name: {arg}')
        if not config.has_option(section, key):
            error(f'Invalid config variable name: {arg}')
        if value is None:
            print(f'{arg}={config.get(section, key)}')
        else:
            config.set(section, key, value)

    writeConfig()


def readCountries(args):
    noArgs(args, "programs")
    countries = getCountries()
    # Replace the entities by their count
    for country in countries:
        country["entities"] = len(country["entities"])
    outputCountries(countries)


def printHelp(args):
    noArgs(args, "help")
    print(
"""Usage: pota [global options] cmd [cmd options] [arguments]

Please note that order is important on the command line!

Available global options are:
  -c <dir>, --cachedir <dir>    Use this directory for cache files
  -f, --fromcache               Work only with the cache, no downloads
  -d, --debug                   Enable debug output
  -j, --json                    Output json data instead of text
  -l <sec>, --ratelimit <sec>   Rate limit API calls
  -n, --nocache                 Do not read or write cached data
  -r, --nocacheread             Do not read from the cache
  -w, --nowritecache            Do not write to the cache

Options -r/-w and -f cannot be used together. If -f is given, the cached data
is used regardless of its age. Commands with lots of API calls will
automatically enable rate limiting if not disabled on the command line.

Available commands and their arguments are:

activations [options] <call|park>
  Print activations for a park or call. For a park, all activations are shown,
  for a call only up to 25 recent ones. Command options:
    -u, --unsuccessful          Include unsuccessful activations

activators [options]
  Print a list of all activators, the number of activations and the number of
  contacts.
    -a, --activations           Sort by number of activations instead of call
    -c <regex>, --call <regex>  Extract calls that match the given regex
    -m <modes>, --mode <modes>  Filter by modes (see below)
    -t, --totals                Add a line with totals
    -T, --TOTALS                Print just one line with totals
    -y <years>, --year <years>  Limit data to the given year (or years)
  The regular expression given to '-c' is a real regex that must match the
  full call sign. It behaves as if it were enclosed in '^...$'. This allows
  to prefix a call filter regex with '^' which negates it. Multiple call
  filters may be used which are 'and' combined. So
    pota activators -a -y 2025 -c 'd[a-r].*' -c '^df5.*'
  prints the list of activators in 2025 with german call signs but excludes
  the ones starting with 'DF5'.
  Entries can be filtered by modes and number of QSOs in this mode. Valid modes
  are 'cw', 'data' or 'phone'. A mode string may just contain a mode name or
  include a comparison operator and a number appended. If there is an
  additional percent sign, the percentage of QSOs in this mode is compared. If
  just a mode is given, a QSO count > 0 is tested. So '-m cw>100' filters all
  activators with more than 100 cw QSOs. '-m cw>50%' applies to all activators
  with more than 50% of their total QSOs in cw. As usual, a match can be
  inverted by prefixing the filter with '^'. More than one mode filter can be
  specified by separating the expressions using commas. In this case the
  filters are 'or' combined. Filters in separate '-m' arguments are 'and'
  combined.
  The '-y' option accepts a single year or a comma separated list of years.
  Example that outputs data from 2024 and 2025 for all call signs starting
  with 'DF5':
    pota activators -y 24,2025 -c 'df5.*'
  Output activators with german call signs from 2025 that have cw qsos:
    pota activators -y 2025 -c 'd[a-r].*' -m cw
  Same as above but with cw only:
    pota activators -y 2025 -c 'd[a-r].*' -m cw -m ^data -m ^phone
  Another way to say the same:
    pota activators -y 2025 -c 'd[a-r].*' -m '^cw<100%'
  Ranking (most activations first) for 2024 excluding data operators:
    pota activators -a -y 2024 -m ^data
  Output all activators that do mostly cw:
    pota activators -a -m 'cw>90%'

awards <call>
  Show the awards for a call.

cleanup
  Cleanup the cache. Remove all outdated data.

config name[=value]
  Query or set configuration variables.
  Currently supported:
    general.callsign    The callsign of the user. Used when spotting.

  The configuration is stored in a file named '.pota' in the users home
  directory.

countries
  Print all countries.

leaderboard <park>
  Print the leader board for a park.

mayor <call|park|region(*)|country(*)>
  Print the mayor for a park, all parks in a region or country or print all
  parks where a user is the mayor (*).
  For a call, only the parks from the last 25 activations are considered.
  Command options:
    -q, --qsos                  Use QSO count instead of activations

parks [country|region]
  Print parks sorted by park reference. Output may be limited to a single
  country or a region. Command options:
    -a, --activations           Sort by number of activations
    -f, --first                 Add first activation info (*)
    -q, --qsos                  Sort by number of qsos

profile <call|park>
  Print the profile for a call or park.

regions [country]
  Print regions. Output may be limited to a single country.

spot [options] call@park freq [mode]
  Post a spot. Command options:
    -c text, --comment text     Post using this text as comment.
  The call@park, freq and mode arguments can be specified in any order. They
  are detected from their syntax. If no mode is given, SSB is assumed. The
  frequency must be specified in kilohertz and may include trailing digits.

  The spotters callsign is taken from the configuration. See the config
  command on how to set it.

  Example:
    pota spot df5wc@de-0008 14032.1 cw -c \"thanks, 73!\"


spots [options]
  Print currently active spots. Command options:
    -f f, --filter f            Add a filter for the displayed spots.
    -q, --qrt                   Include spots marked as qrt.
    -r, --rbn                   Print all spotters including RBN (*)
    -s, --spotters              Print all spotters w/o RBN (*)
  Filter tokens can be bands, calls, modes, parks, regions or countries. All
  filter tokens are compared in full, so you cannot use 'DE-00' to include
  just a subset of parks (those starting with 'DE-00').
  Multiple tokens can be added to one filter separated by commas. In this case
  they are \"or\" combined. Multiple filters specified with -f are \"and\"
  combined. So
    pota spots -f 20m,cw
  prints all spots for 20m and all spots using mode CW, while
    pota spots -f 20m -f cw
  prints all spots for 20m that are using mode CW.
  Filter tokens may be negated using '^' as prefix. So
    pota spots -f ^ft8
  shows all spots except those using FT8. Please note that using negations
  with token lists is almost useless.
    pota spots -f ^ft4,ft8
  will show all spots that aren't FT4 *OR* FT8 which actually means that all
  spots will be shown.

stats <call|park>
  Print statistics for a call or park.

version
  Print the software version.

Options marked with (*) will cause additional API calls and will automatically
apply rate limiting which increases command execution times. It is possible to
override rate limiting by adding '-l 0' to the command line but please note
that this stresses the POTA servers and is rather unfriendly.
""")


def readLeaderboard(args):
    # Park id is mandatory argument
    requireArg(args, "leaderboard")
    arg = args[0].upper()
    if not isPark(arg):
        error(f"Not a valid park id: {arg}")

    outputLeaderboard(getLeaderboard(arg))


def readLocations(args):
    # No arguments
    noArgs(args, "locations")

    locations = sorted(getLocations(), key = lambda loc : loc["locationDesc"])
    outputLocations(locations)


def readMayor(args):
    global rateLimit, defaultRateLimit

    # Parse the command arguments. We accept
    #   -q to use the QSO count for determining the mayor/deputy, and
    #   -d to output mayor AND deputy.
    # The mandatory argument must be: call, park, region or country.
    opts, tokens = getOpt(args, 'dq', [ 'deputy', 'qsos' ])
    requireArg(tokens, "mayor")
    deputy = False
    boardName = "activations"
    unit = "activations"
    for opt, arg in opts:
        if opt in [ '-d', '--deputy' ]:
            deputy = True
        elif opt in [ '-q', '--qsos' ]:
            boardName = "activator_qsos"
            unit = "qsos"
    arg = tokens[0].upper()

    # From the argument, get a park list and a filter function.
    parks = [ ]
    filterFunc = lambda call: True
    if isPark(arg):
        parks.append({ "reference": arg })
    elif isRegion(arg):
        for park in getParks(arg):
            parks.append({ "reference": park["reference"] })
    elif isCountry(arg):
        regions = [ ]
        for region in getRegions(arg):
            regions.append(region["descriptor"])
        for park in getParks(regions):
            parks.append({ "reference": park["reference"] })
    else:
        # First grab the profile and read all activated parks
        activations = getCallActivations(arg)
        # Collect the parks removing duplicates
        addedParks = { }
        for act in activations:
            park = act["reference"]
            if not park in addedParks:
                parks.append({ "reference": park })
                addedParks[park] = True
        # Setup a filter function since we need only those parks in which the
        # call is mayor/deputy
        filterFunc = lambda call: call == arg

    # Get mayor/deputy status for all parks in the list.
    result = [ ]
    for park in parks:
        response = getLeaderboard(park["reference"])
        if not boardName in response:
            error("Data error in response")
        activations = response[boardName]
        validEntry = False
        if len(activations) >= 1:
            call = activations[0]["callsign"]
            if filterFunc(call):
                park["mayor"] = {
                    "callsign": call,
                    "count": activations[0]["count"],
                    "unit": unit
                }
                validEntry = True
        if deputy and len(activations) >= 2:
            call = activations[1]["callsign"]
            if filterFunc(call):
                park["deputy"] = {
                    "callsign": call,
                    "count": activations[1]["count"],
                    "unit": unit
                }
                validEntry = True
        if validEntry:
            result.append(park)

    outputMayor(result)


def readProfile(args):
    # Call or park is mandatory argument
    requireArg(args, "profile")
    arg = args[0].upper()
    if isPark(arg):
        outputParkProfile(getParkProfile(arg))
    else:
        outputCallProfile(getCallProfile(arg))


def readParks(args):
    global defaultRateLimit, rateLimit

    # Parse the command arguments. We accept -a to sort by activations, -q to
    # sort by number of QSOs.
    opts, tokens = getOpt(args, 'afq', [ 'activations', 'first', 'qsos' ])
    sortKey = None
    firstAct = False
    for opt, arg in opts:
        if opt in [ '-a', '--activations' ]:
            if sortKey is not None:
                error("Cannot specify multiple sort options")
            sortKey = "activations"
        elif opt in [ '-f', '--first' ]:
            firstAct = True
        elif opt in [ '-q', '--qsos' ]:
            if sortKey is not None:
                error("Cannot specify multiple sort options")
            sortKey = "qsos"

    # There may be a country or region argument.
    regions = [ ]
    if len(tokens) == 0:
        r = getRegions()
        for region in r:
            regions.append(region["descriptor"])
    elif len(tokens) == 1:
        arg = tokens[0].upper()
        if isCountry(arg):
            r = getRegions(arg)
            for region in r:
                regions.append(region["descriptor"])
        elif isRegion(arg):
            regions.append(arg)
        else:
            error("Not a valid country or region: {arg}")
    else:
        error("Too many arguments for \"parks\"")

    # Apply rate limiting if not overriden from the command line and if the
    # number of regions exceeds a threshold.
    if rateLimit is None and (firstAct or len(regions) > 5):
        rateLimit = defaultRateLimit

    # Read the parks for all regions.
    parks = getParks(regions)

    # If requested, add information about the first activation. This causes a
    # lot of API calls (one per park).
    if firstAct:
        for park in parks:
            profile = getParkProfile(park["reference"])
            if "firstActivator" in profile:
                park["firstActivator"] = profile["firstActivator"]
                park["firstActivationDate"] = profile["firstActivationDate"]
            else:
                park["firstActivator"] = ""

    # Sort the parks as required. Default sort key is reference.
    if sortKey is None:
        sortKey = "reference"
    parks.sort(key = lambda p: p[sortKey])

    # Finally output the parks
    outputParks(parks)


def readRegions(args):
    # May be followed by a country.
    if len(args) == 0:
        regions = getRegions()
    elif len(args) == 1:
        arg = args[0].upper()
        if not isCountry(arg):
            error("Not a valid country: {arg}")
        regions = getRegions(arg)
    else:
        error("Too many arguments for \"regions\"")

    # Output them sorted by descriptor
    regions.sort(key = lambda r: r["descriptor"])
    outputRegions(regions)


def postSpot(args):
    global config

    # We will always use the callsign of the spotter from the config.
    callsign = config.get('general', 'callsign').upper()
    if callsign == "":
        error("Callsign not configured in config")

    # The remainder of the data comes from the command line. We require the
    # comment to come from an option and try to determine the remaining
    # arguments from their type.
    requireArg(args, "spot")
    opts, tokens = getOpt(args, 'c:', [ 'comment=' ], useGnu = True)
    activator = ""
    comment = ""
    freq = ""
    mode = ""
    park = ""
    for opt, arg in opts:
        if opt in [ '-c', '--comment' ]:
            comment = arg
    for tok in tokens:
        if isFreq(tok):
            if freq != "":
                error(f'Frequency specified twice: {freq}/{tok}')
            freq = tok
        elif isMode(tok):
            if mode != "":
                error(f'Mode specified twice: {mode}/{tok}')
            mode = tok.upper()
        elif '@' in tok:
            actData = tok.split('@')
            if len(actData) != 2:
                error(f'Invalid activator/park token: {tok}')
            if not isPark(actData[1]):
                error(f'Invalid park in activator/park token: {tok}')
            if activator != "":
                error(f'Activator specified twice: {activator}/{actData[0]}')
            if park != "":
                # Cannot happen, but we leave it for completeness
                error(f'Park specified twice: {park}/{actData[1]}')
            activator = actData[0].upper()
            park = actData[1].upper()
        else:
            error(f"Don't know how to handle {tok}")

    # Check the data for completeness
    if activator == "":
        error(f'Must specify the activator then spotting')
    if freq == "":
        error(f'Must specify the frequency then spotting')
    if park == "":
        error(f'Must specify the park then spotting')

    # Setup the json for the spot, the post it
    spotData = {
        'activator': activator,
        'spotter': callsign,
        'frequency': freq,
        'reference': park,
        'mode': mode,
        'source': 'pota tool',
        'comments': comment
    }
    postJson("https://api.pota.app/spot/", spotData)


def readSpots(args):
    global defaultRateLimit, rateLimit

    # Parse the command arguments. We accept -q to include spots marked as qrt
    # and -f to add filters
    opts, tokens = getOpt(args, 'f:qrs', [ 'filter', 'qrt', 'rbn', 'spotters' ])
    noArgs(tokens, "spots")
    qrt = False
    addSpotters = 0
    filters = [ ]
    for opt, arg in opts:
        if opt in [ '-f', '--filter' ]:
            filters.append(arg.split(","))
        elif opt in [ '-q', '--qrt' ]:
            qrt = True
        elif opt in [ '-r', '--rbn' ]:
            addSpotters = 2
        elif opt in [ '-s', '--spotters' ]:
            if addSpotters == 0:
                addSpotters = 1

    # Get all spots
    spots = getSpots()

    # Filter the spots as required.
    if not qrt:
        spots = filterList(spots, lambda spot: not "qrt" in spot["comments"].lower())

    # Within one filter, tokens are combined with "or", multiple filters are
    # combined with "and".
    for f in filters:
        validSpots = [ ]
        for spot in spots:
            for filterTok in f:
                tok = filterTok.upper()
                expected = not tok.startswith("^")
                if not expected:
                    tok = tok[1:]
                if isPark(tok):
                    result = (spot["reference"] == tok)
                elif isRegion(tok):
                    result = (tok in spot["locationDesc"])
                elif isBand(tok):
                    result = (spot["band"] == tok)
                elif isMode(tok):
                    result = (spot["mode"] == tok)
                elif isCountry(tok):
                    # Country is the first two letters of the park reference
                    result = (spot["reference"][:2] == tok)
                else:
                    result = (spot["activator"] == tok)
                if expected == result:
                    validSpots.append(spot)
                    # No need to run more filters
                    break
        spots = validSpots
        if len(spots) == 0:
            break

    # If full comments are requested, add them. This requires one API call per
    # spot, so apply rate limiting depending on the number of spots. If there
    # is no request for full comments, unify the data by placing spotter data
    # into a dict similar as with full comments.
    if addSpotters != 0:
        if rateLimit is None and len(spots) > 20:
            rateLimit = defaultRateLimit
        for spot in spots:
            comments = getSpotComments(spot["activator"], spot["reference"])
            if addSpotters < 2:
                comments = filterList(comments, lambda c: not c["spotter"].endswith("#"))
            spot["spotters"] = comments
    else:
        for spot in spots:
            spot["spotters"] = [ {
                'spotter':   spot["spotter"],
                'spotTime':  spot["spotTime"],
                'mode':      spot["mode"],
                'frequency': spot["frequency"],
                'band':      spot["band"],
                'comments':  spot["comments"]
            } ]

    # Sort the spots by frequency then output them
    spots.sort(key = lambda spot : float(spot["frequency"]))
    outputSpots(spots)


def readStats(args):
    # Call or park id is mandatory argument
    requireArg(args, "stats")
    arg = args[0].upper()
    if isPark(arg):
        outputParkStats(getParkStats(arg))
    else:
        outputCallStats(getCallStats(arg))


def printVersion(args):
    noArgs(args, "version")
    info = getVersion()
    if info is None:
        print("unknown")
    else:
        print(f'Version {info["version"]}, last changed on {info["lastChange"]} by {info["author"]}')


###############################################################################
#                                Main program                                 #
###############################################################################


def main():
    global cacheDir, fromCache, debugOutput, jsonOutput, rateLimit
    global readCache, writeCache

    try:
        # Read the options file
        readConfig()

        # Parse command line options
        opts, args = getOpt(
            sys.argv[1:],
            'c:dfjl:rw',
            [
                'cachedir=',
                'debug',
                'fromcache',
                'json',
                'nocacheread',
                'nocachewrite',
                'ratelimit='
            ]
        )

        # Handle options
        for opt, arg in opts:
            if opt in [ '-c', '--cachedir' ]:
                cacheDir = Path(arg)
            elif opt in [ '-d', '--debug' ]:
                debugOutput = True
            elif opt in [ '-f', '--fromcache' ]:
                fromCache = True
            elif opt in [ '-j', '--json' ]:
                jsonOutput = True
            elif opt in [ '-l', '--ratelimit' ]:
                try:
                    rateLimit = float(arg)
                except ValueError:
                    error(f'Argument to {opt} must be a floating point value')
                if rateLimit < 0.0:
                    error(f'Argument to {opt} must not be negative')
            elif opt in [ '-r', '--nocacheread' ]:
                readCache = False
            elif opt in [ '-w', '--nocachewrite' ]:
                writeCache = False

        if not readCache:
            if fromCache:
                error("Options -r and -f cannot be used together")
            debug("Reading from cache is disabled via command line")
        if not writeCache:
            if fromCache:
                error("Options -w and -f cannot be used together")
            debug("Writing to cache is disabled via command line")

        # Setup/create the cache directory
        if cacheDir is None:
            cacheDir = Path.home() / ".local" / "share" / "pota"
        if writeCache and not cacheDir.exists():
            debug(f"Creating cache directory {cacheDir}")
            try:
                cacheDir.mkdir(mode = 0o700, parents = True, exist_ok = True)
            except Exception as e:
                error(f"Error creating {cacheDir}: {e}")
        debug(f"Cache directory is {cacheDir}")

        # Handle commands
        if len(args) == 0:
            error("No command given - use \"pota help\" for help")
        cmd = args[0]
        if cmd == "activations":
            readActivations(args[1:])
        elif cmd == "activators":
            readActivators(args[1:])
        elif cmd == "awards":
            readAwards(args[1:])
        elif cmd == "cleanup":
            cleanupCache(args[1:])
        elif cmd == "config":
            editConfig(args[1:])
        elif cmd == "countries":
            readCountries(args[1:])
        elif cmd == "help":
            printHelp(args[1:])
        elif cmd == "leaderboard":
            readLeaderboard(args[1:])
        elif cmd == "locations":
            readLocations(args[1:])
        elif cmd == "mayor":
            readMayor(args[1:])
        elif cmd == "parks":
            readParks(args[1:])
        elif cmd == "profile":
            readProfile(args[1:])
        elif cmd == "regions":
            readRegions(args[1:])
        elif cmd == "spot":
            postSpot(args[1:])
        elif cmd == "spots":
            readSpots(args[1:])
        elif cmd == "stats":
            readStats(args[1:])
        elif cmd == "version":
            printVersion(args[1:])
        else:
            error(f"Unknown command \"{cmd}\"")

        # Done
        sys.exit(0)

    except BrokenPipeError:
        # Python flushes standard streams on exit; redirect remaining output
        # to devnull to avoid another BrokenPipeError at shutdown
        devnull = os.open(os.devnull, os.O_WRONLY)
        os.dup2(devnull, sys.stdout.fileno())
        if debugOutput:
            sys.stderr.write("SIGPIPE received, terminating.\n")
        sys.exit(1)

if __name__ == "__main__":
    main()
